let AWS = require('aws-sdk');
var docClient = new AWS.DynamoDB.DocumentClient();
var uuid = require("uuid");
const { Client } = require("pg");


function queryDynamo(params, callback, callbackFn) {
    docClient.query(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}

function insertIntoDynamo(params, callback, callbackFn) {
    docClient.put(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}

const batchInsertDynamo = (params, callback, callbackFn) => {
    docClient.batchWrite(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
};

function updateDynamoRecord(params, callback, callbackFn) {
    docClient.update(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}

function scanDynamo(params, callback, callbackFn) {
    docClient.scan(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}

function delete_dynamo(params, callback, callbackFn) {
    docClient.delete(params, function(err, data) {
        if (err) {
            callback(new Error(err));
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}


//utility fucntions
function generate_coupon_codes(quantity, callback, callbackFn) {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let coupon_codes = [];

    function generateString(quantity, length) {
        let coupon = "";
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            coupon += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        if (coupon_codes.indexOf(coupon.trim()) == -1) {
            coupon_codes.push(coupon.trim());
            quantity = quantity - 1;
            if (quantity > 0) {
                return generateString(quantity, length);
            }
            else {
                coupon_codes = coupon_codes.map((item, index) => {
                    item = item + "-" + Number(index + 1);
                    return item;
                });
                callbackFn(coupon_codes);
            }
        }
        else {
            return generateString(quantity, 10);
        }
    }
    return generateString(quantity, 10);
}

function signup_user(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let checkIfUserExists = {
            TableName: 'price_drop_user',
            IndexName: 'user_phone_number-index',
            KeyConditionExpression: '#user_phone_number = :user_phone_number',
            ExpressionAttributeNames: { '#user_phone_number': 'user_phone_number' },
            ExpressionAttributeValues: { ':user_phone_number': event.user_phone_number },
        };
        queryDynamo(checkIfUserExists, callback, function(user) {
            console.log('user', user);
            if (user.Count == 0) {
                let newUserParams = {
                    Item: {
                        user_id: uuid.v4(),
                        user_name: event.user_name,
                        user_country_code: event.user_country_code,
                        user_phone_number: event.user_phone_number,
                        user_device_type: event.user_device_type,
                        user_app_version: event.user_app_version,
                        user_device_version: event.user_device_version,
                        user_status: "ACTIVE",
                        user_created_at: Date.now(),
                        no_of_items_posted: 0,
                    },
                    TableName: 'price_drop_user',
                    ConditionExpression: 'attribute_not_exists(user_id)',
                    ReturnValues: 'ALL_OLD',
                };
                insertIntoDynamo(newUserParams, callback, function(InsertedData) {

                    console.log('insertedData', InsertedData);
                    callback(null, { status: 'Success', status_message: '  Added User Successfully!!', user_details: newUserParams.Item });
                });
            }
            else {
                callback(new Error("User Exists Already"));
            }
        });
    }
    else {
        callback(new Error('Empty Field identified!!! Cannot Signup'));
    }
}

function get_user_details(event, context, callback) {
    if (event.user_phone_number.trim().length != 0) {
        let getUserDetails = {
            TableName: 'price_drop_user',
            IndexName: 'user_phone_number-index',
            KeyConditionExpression: '#user_phone_number = :user_phone_number',
            ExpressionAttributeNames: { '#user_phone_number': 'user_phone_number' },
            ExpressionAttributeValues: { ':user_phone_number': event.user_phone_number },
        };
        queryDynamo(getUserDetails, callback, function(data) {
            if (data.Count > 0) {
                let response = {};
                response.items = data.Items;
                callback(null, { status: 'SUCCESS', data: response });
            }
            else {
                callback(new Error('User With phone_number ' + event.user_phone_number + ' not Found!!'));
            }
        });
    }
    else {
        callback(new Error('Kindly Enter User phone_number to get user details'));
    }
}

function update_user(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let getDeviceUsersParams = {
            TableName: "price_drop_user",
            KeyConditionExpression: "user_id  = :user_id",
            ExpressionAttributeValues: {
                ":user_id": event.user_id
            }
        };
        queryDynamo(getDeviceUsersParams, callback, function(user) {
            if (user.Items.length > 0 && user.Items[0].user_phone_number == event.user_phone_number) {
                let UpdateExpression = 'set';
                let ExpressionAttributeNames = {};
                let ExpressionAttributeValues = {};
                for (const field in event) {
                    if (field == 'user_name' || field == 'user_device_type' || field == 'user_app_version' || field == 'user_device_version' || field == 'fcm_token' || field == 'user_phone_number' || field == 'user_country_code') {
                        UpdateExpression += ` #${field} = :${field} ,`;
                        ExpressionAttributeNames['#' + field] = field;
                        ExpressionAttributeValues[':' + field] = event[field];
                    }
                }
                if (UpdateExpression != 'set') {
                    UpdateExpression = UpdateExpression.slice(0, -1);
                    let updateInternalUserParams = {
                        TableName: 'price_drop_user',
                        Key: {
                            user_id: event.user_id,
                        },
                        UpdateExpression: UpdateExpression,
                        ExpressionAttributeNames: ExpressionAttributeNames,
                        ExpressionAttributeValues: ExpressionAttributeValues,
                        ReturnValues: 'UPDATED_NEW',
                    };
                    updateDynamoRecord(updateInternalUserParams, callback, function(data) {
                        callback(null, { status: 'Successfully', status_message: 'updated user details Successfully!!', data });
                    });
                }
                else {
                    callback(new Error('User with User ID: ' + event.user_id + ' cannot be updated'));
                }
            }
            else {
                callback(new Error("User With ID: " + event.user_id + " Not Found"));
            }
        });
    }
    else {
        callback(new Error("Empty Fields Occcured Cannot Update User Details"));
    }
}

function delete_user(event, context, callback) {
    if (event.user_id != undefined && event.user_id.trim().length > 0) {
        let getUserDetailsParams = {
            TableName: "price_drop_user",
            KeyConditionExpression: "user_id = :user_id",
            ExpressionAttributeValues: {
                ":user_id": event.user_id,
            }
        };
        queryDynamo(getUserDetailsParams, callback, (data) => {
            if (data.Count > 0) {
                console.log(data);
                let deleteUserParams = {
                    TableName: 'price_drop_user',
                    Key: {
                        user_id: event.user_id,
                    },
                };
                delete_dynamo(deleteUserParams, callback, function(data) {
                    callback(null, { status: "SUCCESS", status_message: "User deleted Successfully", data });
                });
            }
            else {
                callback(new Error("Student Not Found!"));
            }
        });
    }
    else {
        callback(new Error("Kindly! Enter User ID To be Updated"));
    }
}

function list_user(event, context, callback) {
    let getCoupon = {
        TableName: 'price_drop_user',
        ScanIndexForward: false,
        Limit: 100,
    };
    scanDynamo(getCoupon, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {}
            callback(null, {
                status: 'SUCCESS',
                data: response,
            });
        }
        else {
            callback(new Error('Currently there are No users'));
        }
    });
}

function create_post(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let getDeviceUsersParams = {
            TableName: "price_drop_user",
            KeyConditionExpression: "user_id  = :user_id",
            ExpressionAttributeValues: {
                ":user_id": event.user_id
            }
        };
        queryDynamo(getDeviceUsersParams, callback, function(user) {
            if (user.Items.length > 0) {
                let createPostParams = {
                    Item: {
                        post_id: uuid.v4(),
                        post_title: event.post_title,
                        post_body: event.post_body,
                        price: event.price,
                        post_images: event.post_images,
                        post_lat: event.post_lat,
                        post_long: event.post_long,
                        user_country_code: user.Items[0].user_country_code,
                        user_phone_number: user.Items[0].user_phone_number,
                        post_status: "LIVE_NOW",
                        post_quantity: event.post_quantity,
                        post_expire_time: event.post_expire_time,
                        original_cost: event.original_cost,
                        user_name: user.Items[0].user_name,
                        post_createdon: Date.now(),
                        user_id: user.Items[0].user_id,
                        verification_status: "PENDING"
                    },
                    TableName: 'price_drop_posts',
                    ConditionExpression: 'attribute_not_exists(post_id)',
                    ReturnValues: 'ALL_OLD',
                };
                insertIntoDynamo(createPostParams, callback, function(data) {
                    //INSERT IN POSTGRE
                    let client = new Client();
                    let query_text = "select * from pd_insert_update_user($1,$2,$3,$4)";
                    client.connect().then((data) => {
                        client.query(query_text, [event.user_id, "ACTIVE", event.post_lat, event.post_long])
                            .then((queryData) => {
                                client.end();
                                // console.log(queryData.rows);
                                generate_coupon_codes(event.post_quantity, callback, function(codes) {
                                    let codesToInsert = [];
                                    while (codes.length) {
                                        codesToInsert.push(codes.splice(0, 25));
                                    }
                                    let promise_array = [];
                                    for (let i = 0; i < codesToInsert.length; i++) {
                                        promise_array.push(new Promise((res, rej) => {
                                            let batchCouponsWriteParams = {
                                                RequestItems: {
                                                    price_drop_coupons: []
                                                },
                                            };
                                            for (let m = 0; m < codesToInsert[i].length; m++) {
                                                batchCouponsWriteParams.RequestItems.price_drop_coupons.push({
                                                    PutRequest: {
                                                        Item: {
                                                            post_id: createPostParams.Item.post_id,
                                                            coupon_id: codesToInsert[i][m],
                                                            coupon_status: "AVAILABLE"
                                                        }
                                                    }
                                                });
                                            }
                                            batchInsertDynamo(batchCouponsWriteParams, callback, function(data) {
                                                res(data);
                                            });
                                        }));
                                    }
                                    Promise.all(promise_array).then((data) => {
                                        callback(null, { status: 'Success', status_message: 'Created Post successfully' });
                                    });
                                });
                            });
                    });
                });
            }
            else {
                callback(new Error("User With ID: " + event.user_id + " Not Found"));
            }
        });
    }
    else {
        callback(new Error("Empty Fields Occcured Cannot Post A Transaction!"));
    }
}

function update_post(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let getDeviceUsersParams = {
            TableName: "price_drop_posts",
            KeyConditionExpression: "post_id  = :post_id",
            ExpressionAttributeValues: {
                ":post_id": event.post_id
            }
        };
        queryDynamo(getDeviceUsersParams, callback, function(user) {
            if (user.Items.length > 0) {
                let UpdateExpression = 'set';
                let ExpressionAttributeNames = {};
                let ExpressionAttributeValues = {};
                for (const field in event) {
                    if (field == 'post_title' || field == 'post_body' || field == 'price' || field == 'post_images' || field == 'post_lat' || field == 'post_long' || field == 'post_address' || field == 'post_quantity' || field == 'post_expire_time' || field == 'original_cost' || field == 'discounted_cost') {
                        UpdateExpression += ` #${field} = :${field} ,`;
                        ExpressionAttributeNames['#' + field] = field;
                        ExpressionAttributeValues[':' + field] = event[field];
                    }
                }
                if (UpdateExpression != 'set') {
                    UpdateExpression = UpdateExpression.slice(0, -1);
                    let updateInternalUserParams = {
                        TableName: "price_drop_posts",
                        Key: {
                            post_id: event.post_id,
                        },
                        UpdateExpression: UpdateExpression,
                        ExpressionAttributeNames: ExpressionAttributeNames,
                        ExpressionAttributeValues: ExpressionAttributeValues,
                        ReturnValues: 'UPDATED_NEW',
                    };
                    console.log(updateInternalUserParams);
                    updateDynamoRecord(updateInternalUserParams, callback, function(data) {
                        callback(null, { status: 'Successfully', status_message: 'updated post details Successfully!!' });
                    });
                }
                else {
                    callback(new Error('User with post ID: ' + event.post_id + ' cannot be updated'));
                }
            }
            else {
                callback(new Error("User With ID: " + event.post_id + " Not Found"));
            }
        });
    }
    else {
        callback(new Error("Empty Fields Occcured Cannot Update Post Details"));
    }
}





function list_posts_to_buy(event, context, callback) {
    //get data from postgressql and sent
    let checkIfPostExists = {
        TableName: 'price_drop_posts',
        IndexName: 'post_status-index',
        KeyConditionExpression: '#post_status = :post_status',
        ExpressionAttributeNames: { '#post_status': 'post_status' },
        ExpressionAttributeValues: { ':post_status': 'LIVE_NOW' },
        Limit: 20
    };
    queryDynamo(checkIfPostExists, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items.sort((a, b) => b.post_createdon - a.post_createdon);
            response.items = response.items;
            if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {}
            let client = new Client();
            let query_text = "select * from pd_get_users_by_location($1)";
            client.connect().then((data) => {
                client.query(query_text, [event.user_id])
                    .then((queryData) => {
                        client.end();

                        callback(null, { status: 'SUCCESS', data: response });
                    });
            });
        }
        else {
            callback(new Error('posts are expired  ' + event.post_status + ' not found!'));
        }
    });
}


function buy_coupon_of_post(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let checkIfUserExistsParams = {
            TableName: "price_drop_user",
            KeyConditionExpression: "user_id  = :user_id",
            ExpressionAttributeValues: {
                ":user_id": event.user_id
            }
        };
        queryDynamo(checkIfUserExistsParams, callback, function(user) {
            if (user.Items.length > 0) {
                let checkIfPostExistsParams = {
                    TableName: "price_drop_posts",
                    KeyConditionExpression: "post_id  = :post_id",
                    FilterExpression: "post_status <> :post_status",
                    ExpressionAttributeValues: {
                        ":post_id": event.post_id,
                        ':post_status': 'EXPIRED'
                    }
                };
                queryDynamo(checkIfPostExistsParams, callback, function(post) {
                    if (post.Items.length > 0) {
                        let checkIfAvailableCouponExistsParams = {
                            TableName: "price_drop_coupons",
                            KeyConditionExpression: "post_id  = :post_id",
                            FilterExpression: "coupon_status = :coupon_status",
                            ExpressionAttributeValues: {
                                ":post_id": event.post_id,
                                ':coupon_status': 'AVAILABLE'
                            }
                        };
                        queryDynamo(checkIfAvailableCouponExistsParams, callback, function(coupons) {
                            if (coupons.Items.length > 0) {
                                let createPurchaseOrderParams = {
                                    Item: {
                                        post_id: event.post_id,
                                        coupon_id: coupons.Items[0].coupon_id,
                                        user_id: event.user_id,
                                        purchase_status: "OPEN",
                                        transaction_id: uuid.v4()
                                    },
                                    TableName: 'price_drop_transactions',
                                    ConditionExpression: 'attribute_not_exists(post_id)',
                                    ReturnValues: 'ALL_OLD',
                                };
                                insertIntoDynamo(createPurchaseOrderParams, callback, function(InsertedData) {
                                    callback(null, { status: 'Success', status_message: 'Purchased Coupon Successfully!!', coupon_code: coupons.Items[0].coupon_id });
                                });
                            }
                            else {
                                callback(new Error("No Available Coupons Found For This Post"));
                            }
                        });
                    }
                    else {
                        callback(new Error("Post With ID: " + event.post_id + " Not Found"));
                    }
                });
            }
            else {
                callback(new Error("User With ID: " + event.user_id + " Not Found"));
            }
        });
    }
    else {
        throw new Error("Empty Fields Occured Cannot Complete the purchase");
    }
}

function list_Transactions_purchased_items(event, context, callback) {
    let getSellersDetails = {
        TableName: 'price_drop_transactions',
        IndexName: 'user_id-index',
        KeyConditionExpression: '#user_id = :user_id',
        ExpressionAttributeNames: { '#user_id': 'user_id' },
        ExpressionAttributeValues: { ':user_id': event.user_id },
    };
    queryDynamo(getSellersDetails, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            callback(null, { status: 'SUCCESS', data: response });
        }
        else {
            callback(new Error('to buy coupons are' + event.user_id + ' not found!'));
        }
    });
}

function delete_post(event, context, callback) {
    if (event.post_id != undefined && event.post_id.trim().length > 0) {
        let getUserDetailsParams = {
            TableName: "price_drop_posts",
            KeyConditionExpression: "post_id = :post_id",
            ExpressionAttributeValues: {
                ":post_id": event.post_id,
            }
        };
        queryDynamo(getUserDetailsParams, callback, (data) => {
            if (data.Count > 0) {
                console.log(data);
                let deleteUserParams = {
                    TableName: 'price_drop_posts',
                    Key: {
                        post_id: event.post_id,
                    },
                };
                delete_dynamo(deleteUserParams, callback, function(data) {
                    callback(null, { status: "SUCCESS", status_message: "post deleted Successfully", data });
                });
            }
            else {
                callback(new Error("post Not Found!"));
            }
        });
    }
    else {
        callback(new Error("Kindly! Enter post ID To be Updated"));
    }
}

function list_post(event, context, callback) {
    let checkIfPostExists = {
        TableName: 'price_drop_posts',
        IndexName: 'post_status-index',
        KeyConditionExpression: '#post_status = :post_status',
        ExpressionAttributeNames: { '#post_status': 'post_status' },
        ExpressionAttributeValues: { ':post_status': 'LIVE_NOW' },
        Limit: 20
    };
    queryDynamo(checkIfPostExists, callback, function(data) {
        if (data.Count > 0) {
            let client = new Client();
            let query_text = "select * from pd_get_users_by_location($1,$2,$3,$4)";
            client.connect().then((pg_data) => {
                client.query(query_text, [event.post_lat, event.post_long, "ACTIVE", 20])
                    .then((queryData) => {
                        client.end();
                        console.log("Postgres Data: ", queryData.rows);
                        let response = {};
                        response.items = data.Items.sort((a, b) => b.post_createdon - a.post_createdon);
                        response.items = response.items;
                        if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {}
                        callback(null, { status: 'SUCCESS', data: response });
                    })
                    .catch(err => {
                        callback(new Error(err));
                    });
            });

        }
        else {
            callback(new Error('posts are expired  ' + event.post_status + ' not found!'));
        }
    });
}

function list_expired_post(event, context, callback) {
    let checkIfExpirePostExists = {
        TableName: 'price_drop_posts',
        IndexName: 'post_status-index',
        KeyConditionExpression: '#post_status = :post_status',
        ExpressionAttributeNames: { '#post_status': 'post_status' },
        ExpressionAttributeValues: { ':post_status': 'EXPIRED' },
    };
    queryDynamo(checkIfExpirePostExists, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            callback(null, { status: 'SUCCESS', data: response });
        }
        else {
            callback(new Error('Expired posts are ' + event.post_status + ' not found!'));
        }
    });
}

function list_coupons(event, context, callback) {
    let getCopuns = {
        TableName: 'price_drop_coupons',
        KeyConditionExpression: '#post_id = :post_id',
        ExpressionAttributeNames: { '#post_id': 'post_id' },
        ExpressionAttributeValues: { ':post_id': event.post_id },
    };
    queryDynamo(getCopuns, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            callback(null, { status: 'SUCCESS', data: response });
        }
        else {
            callback(new Error('sellers posts are' + event.post_status + ' not found!'));
        }
    });
}

function create_buyers(event, context, callback) {
    let checkEmptyFields = true;
    for (const field in event) {
        if (typeof event[field] == 'string') {
            if (event[field].trim().length == 0) {
                checkEmptyFields = false;
            }
        }
    }
    if (checkEmptyFields) {
        let checkIfUserExists = {
            TableName: 'price_drop_buyers',
            KeyConditionExpression: '#user_id = :user_id',
            ExpressionAttributeNames: { '#user_id': "user_id" },
            ExpressionAttributeValues: {
                ":user_id": event.user_id,
            }
        };
        queryDynamo(checkIfUserExists, callback, function(buyer) {
            if (buyer.Count == 0) {
                let buyPostParams = {
                    Item: {
                        user_id: event.user_id,
                        product_body: event.product_body,
                        purchase_status: event.purchase_status,
                        post_id: event.post_id,
                        buyer_phone_number: event.buyer_phone_number,
                        coupon_id: event.coupon_id,
                        product_images: event.product_images,
                        product_address: event.product_address,
                        product_title: event.product_title,
                        product_price: event.product_price
                    },
                    TableName: 'price_drop_buyers',
                    ConditionExpression: 'attribute_not_exists(buyer_id)',
                    ReturnValues: 'ALL_OLD',
                };
                insertIntoDynamo(buyPostParams, callback, function(InsertedData) {
                    callback(null, { status: 'Success', status_message: 'Added post Successfully!!', buyPost_details: buyPostParams.Item });
                });
            }
            else {
                callback(new Error("post Exists Already"));
            }
        });
    }
    else {
        callback(new Error('Empty Field identified!!! Cannot post'));
    }
}

function list_buyers(event, context, callback) {
    let getBuyers = {
        TableName: 'price_drop_buyers',
        ScanIndexForward: false,
        Limit: 100,
    };
    scanDynamo(getBuyers, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {}
            callback(null, {
                status: 'SUCCESS',
                data: response,
            });
        }
        else {
            callback(new Error('Currently there are No buyers'));
        }
    });
}

function list_kyb_user(event, context, callback) {
    let getBuyers = {
        TableName: 'kyb_users',
        ScanIndexForward: false,
        Limit: 100,
    };
    scanDynamo(getBuyers, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {}
            callback(null, {
                status: 'SUCCESS',
                data: response,
            });
        }
        else {
            callback(new Error('Currently there are No buyers'));
        }
    });
}

function list_seller_post(event, context, callback) {
    let getSellersDetails = {
        TableName: 'price_drop_posts',
        IndexName: 'user_phone_number-index',
        KeyConditionExpression: '#user_phone_number = :user_phone_number',
        ExpressionAttributeNames: { '#user_phone_number': 'user_phone_number' },
        ExpressionAttributeValues: { ':user_phone_number': event.user_phone_number },
    };
    queryDynamo(getSellersDetails, callback, function(data) {
        if (data.Count > 0) {
            let response = {};
            response.items = data.Items;
            callback(null, { status: 'SUCCESS', data: response });
        }
        else {
            callback(new Error('sellers posts are' + event.post_status + ' not found!'));
        }
    });
}

function edit_kyb_user(event, context, callback) {
    if (event.user_id.trim().length > 0) {
        let checkIfUserExists = {
            TableName: "kyb_users",
            KeyConditionExpression: "#user_id = :user_id",
            ExpressionAttributeNames: {
                "#user_id": "user_id",
            },
            ExpressionAttributeValues: {
                ":user_id": event.user_id
            }
        };
        queryDynamo(checkIfUserExists, callback, function(user) {
            if (user.Items.length > 0) {
                let UpdateExpression = 'set';
                let ExpressionAttributeNames = {};
                let ExpressionAttributeValues = {};
                for (const field in event) {
                    if (field == 'email_id' || field == 'images' || field == 'location_details' || field == 'identity_proof' || field == 'user_type') {
                        UpdateExpression += ` #${field} = :${field} ,`;
                        ExpressionAttributeNames['#' + field] = field;
                        ExpressionAttributeValues[':' + field] = event[field];
                    }
                }
                UpdateExpression = UpdateExpression + 'user_type = :user_type,';
                ExpressionAttributeValues[':user_type'] = 'BUSINESS';
                if (UpdateExpression != 'set') {
                    UpdateExpression = UpdateExpression.slice(0, -1);
                    let editKybUserParams = {
                        TableName: 'kyb_users',
                        Key: {
                            user_id: user.Items[0].user_id,
                        },
                        UpdateExpression: UpdateExpression,
                        ExpressionAttributeNames: ExpressionAttributeNames,
                        ExpressionAttributeValues: ExpressionAttributeValues,
                        ReturnValues: 'UPDATED_NEW',
                    };
                    updateDynamoRecord(editKybUserParams, callback, function(data) {
                        callback(null, { status: 'Successfully', Status_Message: 'updated user details Successfully!!', data });
                    });
                }
                else {
                    callback(new Error('User with User ID: ' + event.user_id + ' cannot be updated'));
                }
            }
            else {
                callback(new Error("User With ID: " + event.user_id + " Not Found"));
            }
        });
    }
    else {
        callback(new Error("Kindly Enter User ID  To edit User"));
    }
}

function delete_kyb_user(event, context, callback) {
    if (event.user_id != undefined && event.user_id.trim().length > 0) {
        let getUserDetailsParams = {
            TableName: "kyb_users",
            KeyConditionExpression: "user_id = :user_id",
            ExpressionAttributeValues: {
                ":user_id": event.user_id,
            }
        };
        queryDynamo(getUserDetailsParams, callback, (data) => {
            if (data.Count > 0) {
                console.log(data);
                let deleteUserParams = {
                    TableName: 'kyb_users',
                    Key: {
                        user_id: event.user_id,
                    },
                };
                delete_dynamo(deleteUserParams, callback, function(data) {
                    callback(null, { status: "SUCCESS", status_message: "user deleted Successfully", data });
                });
            }
            else {
                callback(new Error("user Not Found!"));
            }
        });
    }
    else {
        callback(new Error("Kindly! Enter user_id to delete"));
    }
}

function purchase_posts_get_expired(event, context, callback) {
    let getStudentDetailsParams = {
        TableName: "price_drop_posts",
        KeyConditionExpression: "post_id = :post_id",
        FilterExpression: "post_status = :post_status",
        ExpressionAttributeValues: {
            ":post_id": event.post_id,
            ":post_status": "LIVE_NOW"
        }
    };
    queryDynamo(getStudentDetailsParams, callback, (data) => {
        if (data.Count > 0) {
            let UpdatePostparams = {
                TableName: "price_drop_posts",
                ExpressionAttributeValues: {
                    ":post_status": "EXPIRED",
                },
                Key: {
                    "post_id": event.post_id
                },
                UpdateExpression: "SET post_status = :post_status",
            };
            updateDynamoRecord(UpdatePostparams, callback, function(data) {
                callback(null, { status: "SUCCESS", status_message: "post expired Successfully" });
            });
        }
        else {
            callback(new Error("post Not Found!"));
        }
    });
}

function list_individual_post(event, callback, context) {
    if (event.post_id.trim().length != 0) {
        let getUserDetails = {
            TableName: 'price_drop_posts',
            KeyConditionExpression: '#post_id = :post_id',
            ExpressionAttributeNames: { '#post_id': 'post_id' },
            ExpressionAttributeValues: { ':post_id': event.post_id },
        };
        queryDynamo(getUserDetails, callback, function(data) {
            if (data.Count > 0) {
                let response = {};
                response.items = data.Items;
                callback(null, { status: 'SUCCESS', data: response });
            }
            else {
                callback(new Error('post ' + event.post_id + ' not Found!!'));
            }
        });
    }
    else {
        callback(new Error('Kindly Enter post id to get post details'));
    }
}



exports.handler = (event, context, callback) => {
    console.log(event);
    switch (event.command) {
        case 'signUpUser':
            signup_user(event, context, callback);
            break;
        case "getUserDetails":
            get_user_details(event, context, callback);
            break;
        case "updateUser":
            update_user(event, context, callback);
            break;
        case "listUser":
            list_user(event, context, callback);
            break;
        case "createPost":
            create_post(event, context, callback);
            break;
        case "listPostsToBuy":
            list_posts_to_buy(event, context, callback);
            break;
        case "buyCouponOfPost":
            buy_coupon_of_post(event, context, callback);
            break;
        case "listTransctionsOfPurchasedItems":
            list_Transactions_purchased_items(event, context, callback);
            break;
        case "deleteUser":
            delete_user(event, context, callback);
            break;
        case "deletePost":
            delete_post(event, context, callback);
            break;
        case "listPost":
            list_post(event, context, callback);
            break;
        case "listExpirePost":
            list_expired_post(event, context, callback);
            break;
        case "upDatePost":
            update_post(event, context, callback);
            break;
        case "ListCoupons":
            list_coupons(event, context, callback);
            break;
        case "createBuyers":
            create_buyers(event, context, callback);
            break;
        case "listBuyers":
            list_buyers(event, context, callback);
            break;
        case "listKybUser":
            list_kyb_user(event, context, callback);
            break;
        case "listSellerPost":
            list_seller_post(event, context, callback);
            break;
        case "editKybUser":
            edit_kyb_user(event, context, callback);
            break;
        case "deleteKybUser":
            delete_kyb_user(event, context, callback);
            break;
        case "PurchasePostsGetExpired":
            purchase_posts_get_expired(event, context, callback);
            break;
        case "listIndividulPost":
            list_individual_post(event, callback, context);
            break;
        default:
            callback(new Error("Command not Found!"));
    }
};
